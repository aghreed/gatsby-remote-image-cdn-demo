diff --git a/node_modules/gatsby-plugin-remote-images/gatsby-node.js b/node_modules/gatsby-plugin-remote-images/gatsby-node.js
index 27af4e1..3b1b9cf 100644
--- a/node_modules/gatsby-plugin-remote-images/gatsby-node.js
+++ b/node_modules/gatsby-plugin-remote-images/gatsby-node.js
@@ -1,56 +1,56 @@
-"use strict";
+'use strict';
 
+const { createRemoteFileNode } = require(`gatsby-source-filesystem`);
 const {
-  createRemoteFileNode
-} = require(`gatsby-source-filesystem`);
-const {
-  addRemoteFilePolyfillInterface
+  addRemoteFilePolyfillInterface,
 } = require('gatsby-plugin-utils/polyfill-remote-file');
 const get = require('lodash/get');
 const probe = require('probe-image-size');
 let i = 0;
-exports.pluginOptionsSchema = ({
-  Joi
-}) => {
+exports.pluginOptionsSchema = ({ Joi }) => {
   return Joi.object({
-    mode: Joi.string().valid('cdn', 'local').default('local')
+    nodeType: Joi.string().required(),
+    imagePath: Joi.string().required(),
+    name: Joi.string(),
+    auth: Joi.object(),
+    ext: Joi.string(),
+    prepareUrl: Joi.function(),
+    type: Joi.object(),
+    silent: Joi.boolean(),
   });
 };
-exports.createSchemaCustomization = ({
-  actions,
-  schema
-}, {
-  mode
-}) => {
-  if (mode === 'cdn') {
-    const RemoteImageFileType = addRemoteFilePolyfillInterface(schema.buildObjectType({
-      name: 'RemoteImageFile',
-      fields: {
-        id: 'ID!'
-      },
-      interfaces: ['Node', 'RemoteFile'],
-      extensions: {
-        infer: true
+const isImageCdnEnabled = () => {
+  return (
+    process.env.GATSBY_CLOUD_IMAGE_CDN === '1' ||
+    process.env.GATSBY_CLOUD_IMAGE_CDN === 'true'
+  );
+};
+exports.createSchemaCustomization = ({ actions, schema }) => {
+  if (isImageCdnEnabled()) {
+    const RemoteImageFileType = addRemoteFilePolyfillInterface(
+      schema.buildObjectType({
+        name: 'RemoteImageFile',
+        fields: {
+          id: 'ID!',
+        },
+        interfaces: ['Node', 'RemoteFile'],
+        extensions: {
+          infer: true,
+        },
+      }),
+      {
+        schema,
+        actions,
       }
-    }), {
-      schema,
-      actions
-    });
+    );
     actions.createTypes([RemoteImageFileType]);
   }
 };
-exports.onCreateNode = async ({
-  node,
-  actions,
-  store,
-  cache,
-  createNodeId,
-  createContentDigest,
-  reporter
-}, options) => {
-  const {
-    createNode
-  } = actions;
+exports.onCreateNode = async (
+  { node, actions, store, cache, createNodeId, createContentDigest, reporter },
+  options
+) => {
+  const { createNode } = actions;
   const {
     nodeType,
     imagePath,
@@ -60,7 +60,6 @@ exports.onCreateNode = async ({
     prepareUrl = null,
     type = 'object',
     silent = false,
-    mode
   } = options;
   const createImageNodeOptions = {
     store,
@@ -72,7 +71,6 @@ exports.onCreateNode = async ({
     ext,
     name,
     prepareUrl,
-    mode
   };
   if (node.internal.type === nodeType) {
     // Check if any part of the path indicates the node is an array and splits at those indicators
@@ -83,12 +81,24 @@ exports.onCreateNode = async ({
     if (imagePathSegments.length) {
       const urls = await getAllFilesUrls(imagePathSegments[0], node, {
         imagePathSegments,
-        ...createImageNodeOptions
+        ...createImageNodeOptions,
       });
-      await createImageNodes(urls, node, createImageNodeOptions, reporter, silent);
+      await createImageNodes(
+        urls,
+        node,
+        createImageNodeOptions,
+        reporter,
+        silent
+      );
     } else if (type === 'array') {
       const urls = getPaths(node, imagePath, ext);
-      await createImageNodes(urls, node, createImageNodeOptions, reporter, silent);
+      await createImageNodes(
+        urls,
+        node,
+        createImageNodeOptions,
+        reporter,
+        silent
+      );
     } else {
       const url = getPath(node, imagePath, ext);
       await createImageNode(url, node, createImageNodeOptions, reporter);
@@ -98,7 +108,7 @@ exports.onCreateNode = async ({
 function getPaths(node, path, ext = null) {
   const value = get(node, path);
   if (value) {
-    return value.map(url => ext ? url + ext : url);
+    return value.map(url => (ext ? url + ext : url));
   }
 }
 
@@ -113,34 +123,33 @@ function getCacheKeyForNodeId(nodeId) {
   return `gatsby-plugin-remote-images-${nodeId}`;
 }
 async function createImageNodes(urls, node, options, reporter, silent) {
-  const {
-    name,
-    imagePathSegments,
-    prepareUrl,
-    ...restOfOptions
-  } = options;
+  const { name, imagePathSegments, prepareUrl, ...restOfOptions } = options;
   let fileNode;
   if (!urls) {
     return;
   }
-  const fileNodes = (await Promise.all(urls.map(async (url, index) => {
-    if (typeof prepareUrl === 'function') {
-      url = prepareUrl(url);
-    }
-    try {
-      fileNode = await createRemoteFileNode({
-        ...restOfOptions,
-        url,
-        parentNodeId: node.id
-      });
-      reporter.verbose(`Created image from ${url}`);
-    } catch (e) {
-      if (!silent) {
-        reporter.error(`gatsby-plugin-remote-images ERROR:`, new Error(e));
-      }
-    }
-    return fileNode;
-  }))).filter(fileNode => !!fileNode);
+  const fileNodes = (
+    await Promise.all(
+      urls.map(async (url, index) => {
+        if (typeof prepareUrl === 'function') {
+          url = prepareUrl(url);
+        }
+        try {
+          fileNode = await createRemoteFileNode({
+            ...restOfOptions,
+            url,
+            parentNodeId: node.id,
+          });
+          reporter.verbose(`Created image from ${url}`);
+        } catch (e) {
+          if (!silent) {
+            reporter.error(`gatsby-plugin-remote-images ERROR:`, new Error(e));
+          }
+        }
+        return fileNode;
+      })
+    )
+  ).filter(fileNode => !!fileNode);
 
   // Store the mapping between the current node and the newly created File node
   if (fileNodes.length) {
@@ -156,30 +165,22 @@ async function createImageNodes(urls, node, options, reporter, silent) {
     const existingFileNodeMap = await options.cache.get(cacheKey);
     await options.cache.set(cacheKey, {
       ...existingFileNodeMap,
-      [name]: fileNodes.map(({
-        id
-      }) => id)
+      [name]: fileNodes.map(({ id }) => id),
     });
   }
 }
 
 // Creates a file node and associates the parent node to its new child
 async function createImageNode(url, node, options, reporter, silent) {
-  const {
-    name,
-    mode,
-    imagePathSegments,
-    prepareUrl,
-    ...restOfOptions
-  } = options;
+  const { name, imagePathSegments, prepareUrl, ...restOfOptions } = options;
   let fileNodeId;
   let fileNode;
   if (typeof prepareUrl === 'function') {
     url = prepareUrl(url);
   }
   try {
-    if (mode === 'cdn') {
-      fieldNodeId = options.createNodeId(`RemoteImageFile >>> ${node.id}`);
+    if (isImageCdnEnabled()) {
+      fileNodeId = options.createNodeId(`RemoteImageFile >>> ${node.id}`);
       const metadata = await probe(url);
       await options.createNode({
         id: fileNodeId,
@@ -191,8 +192,8 @@ async function createImageNode(url, node, options, reporter, silent) {
         mimeType: metadata.mime,
         internal: {
           type: 'RemoteImageFile',
-          contentDigest: node.internal.contentDigest
-        }
+          contentDigest: node.internal.contentDigest,
+        },
       });
       if (!silent) {
         reporter.verbose(`Created RemoteImageFile node from ${url}`);
@@ -201,7 +202,7 @@ async function createImageNode(url, node, options, reporter, silent) {
       fileNode = await createRemoteFileNode({
         ...restOfOptions,
         url,
-        parentNodeId: node.id
+        parentNodeId: node.id,
       });
       fileNodeId = fileNode.id;
       if (!silent) {
@@ -213,21 +214,24 @@ async function createImageNode(url, node, options, reporter, silent) {
       reporter.error(`gatsby-plugin-remote-images ERROR:`, new Error(e));
     }
     ++i;
-    fileNode = await options.createNode({
-      id: options.createNodeId(`${i}`),
-      parent: node.id,
-      internal: {
-        type: 'File',
-        mediaType: 'application/octet-stream',
-        contentDigest: options.createContentDigest(`${i}`)
+    fileNode = await options.createNode(
+      {
+        id: options.createNodeId(`${i}`),
+        parent: node.id,
+        internal: {
+          type: 'File',
+          mediaType: 'application/octet-stream',
+          contentDigest: options.createContentDigest(`${i}`),
+        },
+      },
+      {
+        name: 'gatsby-source-filesystem',
       }
-    }, {
-      name: 'gatsby-source-filesystem'
-    });
+    );
   }
 
   // Store the mapping between the current node and the newly created File node
-  if (fileNode) {
+  if (fileNode || isImageCdnEnabled()) {
     // This associates the existing node (of user-specified type) with the new
     // File nodes created via createRemoteFileNode. The new File nodes will be
     // resolved dynamically through the Gatsby schema customization
@@ -240,7 +244,7 @@ async function createImageNode(url, node, options, reporter, silent) {
     const existingFileNodeMap = await options.cache.get(cacheKey);
     await options.cache.set(cacheKey, {
       ...existingFileNodeMap,
-      [name]: fileNode.id
+      [name]: fileNode ? fileNode.id : fileNodeId,
     });
   }
 }
@@ -250,64 +254,65 @@ async function getAllFilesUrls(path, node, options) {
   if (!path || !node) {
     return;
   }
-  const {
-    imagePathSegments,
-    ext
-  } = options;
+  const { imagePathSegments, ext } = options;
   const pathIndex = imagePathSegments.indexOf(path),
     isPathToLeafProperty = pathIndex === imagePathSegments.length - 1,
     nextValue = getPath(node, path, isPathToLeafProperty ? ext : null);
 
   // @TODO: Need logic to handle if the leaf node is an array to then shift
   // to the function of createImageNodes.
-  return Array.isArray(nextValue) && !isPathToLeafProperty ?
-  // Recursively call function with next path segment for each array element
-  (await Promise.all(nextValue.map(item => getAllFilesUrls(imagePathSegments[pathIndex + 1], item, options)))).reduce((arr, row) => arr.concat(row), []) :
-  // otherwise, handle leaf node
-  nextValue;
+  return Array.isArray(nextValue) && !isPathToLeafProperty
+    ? // Recursively call function with next path segment for each array element
+      (
+        await Promise.all(
+          nextValue.map(item =>
+            getAllFilesUrls(imagePathSegments[pathIndex + 1], item, options)
+          )
+        )
+      ).reduce((arr, row) => arr.concat(row), [])
+    : // otherwise, handle leaf node
+      nextValue;
 }
-exports.createResolvers = ({
-  cache,
-  createResolvers
-}, options) => {
-  const {
-    nodeType,
-    imagePath,
-    name = 'localImage',
-    type = 'object'
-  } = options;
+exports.createResolvers = ({ cache, createResolvers }, options) => {
+  const { nodeType, imagePath, name = 'localImage', type = 'object' } = options;
   if (type === 'array' || imagePath.includes('[].')) {
     const resolvers = {
       [nodeType]: {
         [name]: {
-          type: options.mode === 'cdn' ? '[RemoteImageFile]' : '[File]',
+          type: isImageCdnEnabled() ? '[RemoteImageFile]' : '[File]',
           resolve: async (source, _, context) => {
-            const fileNodeMap = await cache.get(getCacheKeyForNodeId(source.id));
+            const fileNodeMap = await cache.get(
+              getCacheKeyForNodeId(source.id)
+            );
             if (!fileNodeMap || !fileNodeMap[name]) {
               return [];
             }
-            return fileNodeMap[name].map(id => context.nodeModel.getNodeById({
-              id
-            }));
-          }
-        }
-      }
+            return fileNodeMap[name].map(id =>
+              context.nodeModel.getNodeById({
+                id,
+              })
+            );
+          },
+        },
+      },
     };
     createResolvers(resolvers);
   } else {
     const resolvers = {
       [nodeType]: {
         [name]: {
-          type: options.mode === 'cdn' ? 'RemoteImageFile' : 'File',
+          type: isImageCdnEnabled() ? 'RemoteImageFile' : 'File',
           resolve: async (source, _, context) => {
-            const fileNodeMap = await cache.get(getCacheKeyForNodeId(source.id));
+            const fileNodeMap = await cache.get(
+              getCacheKeyForNodeId(source.id)
+            );
             if (!fileNodeMap) return null;
             return context.nodeModel.getNodeById({
-              id: fileNodeMap[name]
+              id: fileNodeMap[name],
             });
-          }
-        }
-      }
+          },
+        },
+      },
     };
     createResolvers(resolvers);
   }
